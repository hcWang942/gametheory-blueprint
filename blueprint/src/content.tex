\title{Auction Theory Blueprint} 


\home{https://hcWang942.github.io/gametheory-blueprint/}
\github{https://github.com/hcWang942/gametheory-blueprint/}
\dochome{https://hcWang942.github.io/gametheory-blueprint/doc/}

% \home{localhost:8000}
% \dochome{localhost:8000/doc}

\maketitle


\tableofcontents
\section{Introduction}
Mathematics is typically presented in natural language, results are stated this way, and proofs are given this way. Mathematicians use special symbols to denote mathematical objects and operations, but the reasoning is presented in natural langauge. Logicians have defined formal languages for writing statements and representing reasoning. The process of formalization of mathematics is the process of using a computer to reason about mathematics.

These formal languages specify the rules of reasoning. Given these formal languages and the prescribed rules of reasoning, an reasoning is correct if it is licensed by the prescribed rules of reasoning at each step, and the correctness of the reasoning can be checked by checking whether it is allowed by the prescribed rules of reasoning at each step. Because the rules are mechanical, the process of checking for correctness is also mechanical. This ensures that the correctness of a formal proof is objective and algorithmically checkable.
%https://www.contrib.andrew.cmu.edu/~avigad/Students/zipperer_ms_thesis.pdf
This process can be divided into two main parts: expressing the statements of theorems in a formal language, and writing proofs using a fixed set of formal reasoning rules that can be checked algorithmically.

% https://webusers.imj-prg.fr/~riccardo.brasca/event/luxembourg-2021/pres.pdf
%https://www.andrew.cmu.edu/user/avigad/Teaching/practical/slides_upitt.pdf
This project finish the formalization process of several theorems in Auction Theory using the proof assistant Lean4 and its mathematical library, Mathlib4. Lean4 is a software tool to assist with the development of formal proofs. Mathlib4 is a user maintained library for the Lean Theorem Prover. It contains both programming infrastructure and mathematics, as well as tactics that might be used to complete the formalization.

The further goal is to refine the formally state theorems and contribute to the repository of Mathlib4 by creating a pull request. This bridges the gap between informal and formal mathematical reasoning and demonstrate the capabilities of modern proof assistants in handling complex mathematical concepts.

\section{Main result}
Auction Theory is a branch of economics that deals with the design and analysis of auction mechanisms. We will focus on formalizing key results from Auction Theory, including first-price and second-price auctions and Myerson's Lemma. 

Main result of formalization incluing one lemma in first-price auction, in which state that there is no dominant strategy in first-price auction. 

\begin{lemma}[First-Price Auction has no dominant strategy]
In a sealed-bid first-price auction, no bidder has a dominant strategy.
\end{lemma}

And two lemmas in second-price auction.

\begin{lemma}[Incentives in Second-Price Auctions]
In a second-price auction, every bidder i has a dominant strategy: set the bid bi equal to her private valuation \(v_i\).
\end{lemma}

\begin{lemma}[Nonnegative Utility] In a second-price auction, every truthful bidder is guaranteed nonnegative utility.
\end{lemma}

By using Lean4 and Mathlib4, we 


The formalization process involves translating natural language descriptions of auction mechanisms and their properties into formal statements and proofs. This involves defining the auction structures, bidding strategies, and utility functions formally, and proving fundamental results about these structures using Lean4. 

This project is a step towards the goal of computer verification of current research in very abstract mathematics.Showing that formal methods are capable of verifying complex mathematical research.

%!TEX root = Thesis.tex
\chapter{Lean and Mathlib}

The Lean Theorem Prover and Programming Language is developed principally by Leonardo de Moura when he was at Microsoft Research in 2013. Lean is a software tool to assist with the development of formal proofs by human-machine collaboration. Lean 4 is the latest version.

Mathlib is a user maintained library for the Lean Theorem Prover. It contains both programming infrastructure and mathematics, as well as tactics that use the former and allow to develop the latter.


\subsection{The Lean Theorem Prover and Programming Language}
\subsubsection{What is a Proof Assistant}
A proof assistant is a piece of software that provides a language for defining objects, specifying properties of these objects, and proving that these specifications hold. In a more general word, proof assistant translate state written by human being to the state that totally precise. A proof assistant has two components. First is the kernel, which checks that the proof is formally correct. The other is the elaborator. It translates a proof written by a human to something the kernel can check.
% https://webusers.imj-prg.fr/~riccardo.brasca/event/luxembourg-2021/pres.pdf

The system checks that these proofs are correct down to their logical foundation. This combination of human creativity with machine precision improves the reliability of proofs and supports complex mathematical reasoning. In a formalization, all definitions are precisely specified and all proofs are guaranteed to be correct. For instance, Coq, Isabelle/HOL (Higher-order logic) and Lean.
\subsection{The Lean Theorem Prover and Programming Language}
The Lean is first developed in 2013 by Leonardo de Moura at Microsoft Research. The Lean 4 was released at the beginning of 2021, marking a significant evolution from  Lean 3. The primary distinction is that Lean 4 is designed as a general-purpose programming language, not solely as an interactive theorem prover.It is capable of generating executables that are impressively fast. Additionally, Lean 4 supports calling into C++ and employs reference counting techniques that enable functionally written code to be compiled such that it updates in-place when appropriate.


Lean uses a system of dependent types based on
the calculus of inductive constructions (CIC)%[52]
, and is is particularly known for its use of dependent type theory, which allows types to depend on values. Lean checks that every expression has a type. Types are treated as first-class citizens in Lean. %https://lean-lang.org/functional_programming_in_lean/getting-to-know/summary.html
This means that just like values, types can be passed as arguments, returned from functions, and manipulated within the language. This feature is significant for modeling complex mathematical and computational concepts directly in the type system. Brand new types can be introduced to Lean using the 'structure' or 'inductive' features. These new types are not considered to be equivalent to any other type, even if their definitions are otherwise identical. This also enhance the flexibility and creativity of Lean.




\subsubsection{Mathlib: The Lean Mathematical Library}
%Foundation and Purpose
Mathlib is a user maintained library for the Lean theorem prover. An easy way to understand is that mathlib is a repository of mathematical formalized proofs.  Essentially, it functions as a comprehensive repository of formally formalized mathematical theorems, where the theorems can be imported into respective projects, thereby facilitating the proof development and formalization.

Mathlib was first established in 2017 by a group of users with very diverse backgrounds, where the Lean 3 is the latest version. It contains both programming infrastructure and mathematics, as well as tactics that use the former and allow to develop the latter. The mathlib library is designed as a basis for research level mathematics. The development of Mathlib is characterized by its dynamic and active community. With regular contributions from a global array of participants, The library contains useful definitions for programming. This project is very active, with many regular contributors and daily activity. Currently, much of mathlib consists of undergraduate level mathematics. %https://leanprover-community.github.io/

\section{Introduction}

This section formalizes core concepts and results in auction theory using the Lean theorem prover. Our approach focuses on establishing a rigorous framework that captures the dynamics and strategic behaviors in auctions.

\subsection{Main Definitions}

\begin{itemize}
    \item \textbf{Auction}: Defines an auction setup including bidders and their respective valuations.
    \item \textbf{maxb}: A function to compute the highest bid within a given set of bids.
    \item \textbf{winner}: Identifies the auction winner as the bidder with the highest bid.
    \item \textbf{utility}: Calculates the utility for each bidder, taking into account their bid and the auction outcome.
    \item \textbf{dominant}: Determines whether a bidding strategy is dominant for a bidder.
\end{itemize}

\subsection{Main Results}

\begin{itemize}
    \item \textbf{exists\_max}: Proves the existence of a participant whose bid is equal to the highest bid.
    \item \textbf{winner\_take\_max}: Ensures that the bid of the winner is the highest among all bidders.
    \item \textbf{b\_winner}: Asserts that the winner's bid surpasses or matches the second highest bid.
    \item \textbf{valuation\_is\_dominant}: Demonstrates that bidding one's own valuation is a dominant strategy.
\end{itemize}

\subsection{Notations}

\begin{itemize}
    \item \( |b| \): Denotes a bidding function.
    \item \( \text{maxb}(b) \): Represents the highest bid in the function \( b \).
    \item \( B_i \): Stands for the maximal bid of all participants except participant \( i \).
\end{itemize}

\subsection{Implementation Notes}

The defined structures and functions are crafted to accommodate multiple bidders, enhancing the realism and applicability of auction models. Key definitions such as \textit{winner} and \textit{maxb} leverage Lean's \textit{Finset} and \textit{Classical} logic modules to effectively manage non-constructive scenarios.

\subsection{References}

Our theoretical groundwork is supported by classical texts and research papers in auction theory, adapting their general proofs to the structured environment of Lean.

\subsection{Tags}

Keywords relevant to this work include \textit{auction}, \textit{game theory}, \textit{economics}, \textit{bidding}, and \textit{valuation}.



\section{Example}
Here you can use LaTex. \cite{marcus}. You must cite something to make it work.

\begin{lemma}\label{two_different_elements}
    \leanok
    \lean{two_different_elements}
    Here is a documentation.
\end{lemma}

\begin{proof}
    Here is a proof.
\end{proof}

\begin{definition}\label{Auction}
    \leanok
    \lean{Auction}
    \uses{two_different_elements}
    This is the structure definition of the formalized auction theory project.
\end{definition}

\begin{definition}\label{maxb}
    \leanok
    \lean{maxb}
    maxb is set to compute the highest bid given a bidding function `b`.
\end{definition}

\begin{lemma}\label{exists_max}
    \leanok
    \lean{exists_max}
    There exists a participant `i` whose bid equals the highest bid.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}


\begin{definition}\label{winner}
    \leanok
    \lean{winner}
    \uses{exists_max }
    winner: The participant with the highest bid.
\end{definition}

\begin{lemma}\label{winner_take_max}
    \leanok
    \lean{winner_take_max}
    \uses{maxb, exists_max, winner}
    Here is a definition.
\end{lemma}
\begin{proof}
    The bid of the winner equals the highest bid.
\end{proof}

\begin{lemma}\label{delete_i_nonempty}
    \leanok
    \lean{delete_i_nonempty}
    Removing a participant `i` from all participants still leaves a non-empty set.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{definition}\label{B}
    \leanok
    \lean{B}
    \uses{delete_i_nonempty}
    State that `B i` is the maximal bid of all participants but `i`.
\end{definition}

\begin{definition}\label{secondprice}
    \leanok
    \lean{secondprice}
    \uses{winner, B}
    The secondprice refers to the second highest bid, i.e. the highest bid excluding the winnerâ€™s bid.
\end{definition}

\begin{definition}\label{utility}
    \leanok
    \lean{utility}
    \uses{winner, secondprice}
    Defines the utility of participant `i`, which is their valuation minus the second highest bid if `i` is the winner, otherwise, it's 0.
\end{definition}

\begin{lemma}\label{utility_winner}
    \leanok
    \lean{utility_winner}
    \uses{utility, secondprice}
    If `i` is the winner, then their utility is their valuation minus the second highest bid.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{lemma}\label{utility_loser}
    \leanok
    \lean{utility_loser}
    \uses{utility, winner}
    If `i` is not the winner, then their utility is 0.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{definition}\label{dominant}
    \leanok
    \lean{dominant}
    \uses{utility}
    A strategy is dominant if bidding `bi` ensures that bidder `i`'s utility is maximized relative to any other bids `b'` where `b i = bi`.
\end{definition}


\begin{lemma}\label{gt_wins}
    \leanok
    \lean{gt_wins}
    \uses{winner, maxb, winner_take_max}
    Here is a definition.
\end{lemma}
\begin{proof}
    If `i`'s bid is higher than all other bids, then `i` is the winner.
\end{proof}



\begin{lemma}\label{b_winner_max}
    \leanok
    \lean{b_winner_max}
    \uses{winner, maxb, winner_take_max}
    The bid of the winner is always greater than or equal to the bids of all other participants.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{lemma}\label{b_winner}
    \leanok
    \lean{b_winner}
    \uses{winner, secondprice ,winner_take_max,  delete_i_nonempty}
    The bid of the winner is always greater than or equal to the second highest bid.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{lemma}\label{b_loser_max}
    \leanok
    \lean{b_loser_max}
    \uses{winner, maxb ,winner_take_max}
    If `i` is not the winner, then the highest bid excluding `i` is equal to the overall highest bid.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{lemma}\label{utility_nneg}
    \leanok
    \lean{utility_nneg}
    \uses{utility, winner, secondprice ,winner_take_max, maxb}
    Here is a definition.
\end{lemma}
\begin{proof}
    Utility is non-negative if the bid equals the valuation.
\end{proof}

\begin{lemma}\label{valuation_is_dominant}
    \leanok
    \lean{valuation_is_dominant}
    \uses{dominant, winner, gt_wins, utility_winner, secondprice , 
          delete_i_nonempty, utility_nneg}
          Proves that the strategy of bidding one's valuation is a dominant strategy for `i`.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{definition}\label{Utility.FirstPrice}
    \leanok
    \lean{Utility.FirstPrice}
    \uses{winner}
    Computes the utility for a first price auction where the winner pays their bid.
\end{definition}

\begin{lemma}\label{utility_first_price_winner}
    \leanok
    \lean{utility_first_price_winner}
    \uses{winner, Utility.FirstPrice}
    If `i` is the winner in a first price auction, their utility is their valuation minus their bid.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{lemma}\label{utility_first_price_loser}
    \leanok
    \lean{utility_first_price_winner}
    \uses{winner, Utility.FirstPrice}
    If `i` is not the winner in a first price auction, their utility is 0.
\end{lemma}
\begin{proof}
    Here is a proof.
\end{proof}

\begin{definition}\label{Dominant.FirstPrice}
    \leanok
    \lean{Dominant.FirstPrice}
    \uses{Utility.FirstPrice}
    Defines a dominant strategy in the context of a first price auction.
\end{definition}

\begin{theorem}\label{first_price_has_no_dominant_strategy}
    \leanok
    \lean{first_price_has_no_dominant_strategy}
    \uses{Dominant.FirstPrice, winner, gt_wins}
    There is no dominant strategy in a first price auction for any `i` and any bid `bi`.
\end{theorem}
\begin{proof}
    Here is a proof.
\end{proof}







% \begin{definition}\label{SingleParameterEnvironment}
%     \leanok
%     \lean{SingleParameterEnvironment}
%     Here is a definition.
% \end{definition}

% \begin{definition}\label{Nonempty E.I}
%     \leanok
%     \lean{Nonempty E.I}
%     Here is a definition.
% \end{definition}

% \begin{definition}\label{Fintype E.I }
%     \leanok
%     \lean{Dominant.FirstPrice}
%     Here is a definition.
% \end{definition}

% \begin{definition}\label{Nonempty (E.feasibleSet) }
%     \leanok
%     \lean{Dominant.FirstPrice}
%     Here is a definition.
% \end{definition}

% \begin{definition}\label{CoeFun E.feasibleSet}
%     \leanok
%     \lean{CoeFun E.feasibleSet}
%     Here is a definition.
% \end{definition}


% \begin{definition}\label{DirectRevelationMechanism}
%     \leanok
%     \lean{Dominant.FirstPrice}
%     \uses{Utility.FirstPrice}
%     Here is a definition.
% \end{definition}


% \begin{definition}\label{utility}
%     \leanok
%     \lean{utility}
%     Here is a definition.
% \end{definition}

% \begin{definition}\label{dominant}
%     \leanok
%     \lean{utility}
%     \uses{utility}
%     Here is a definition.
% \end{definition}

% \begin{definition}\label{dsic}
%     \leanok
%     \lean{dsic}
%     \uses{dominant}
%     Here is a definition.
% \end{definition}


% \begin{definition}\label{nondecreasingy}
%     \leanok
%     \lean{nondecreasing}
%     Here is a definition.
% \end{definition}


% \begin{definition}\label{with_hole}
%     \leanok
%     \lean{with_hole}
%     Here is a definition.
% \end{definition}

% \begin{lemma}\label{filled_hole_retrieve}
%     \leanok
%     \lean{filled_hole_retrieve}
%     \uses{with_hole}
%     Here is a definition.
% \end{lemma}
% \begin{proof}
%     Here is a proof.
% \end{proof}


% \begin{lemma}\label{filled_hole_retrieve_other}
%     \leanok
%     \lean{utility_nneg}
%     \uses{with_hole}
%     Here is a definition.
% \end{lemma}
% \begin{proof}
%     Here is a proof.
% \end{proof}


% \begin{lemma}\label{filled_hole_almost_equal}
%     \leanok
%     \lean{filled_hole_almost_equal}
%     \uses{with_hole, filled_hole_retrieve_other}
%     Here is a definition.
% \end{lemma}
% \begin{proof}
%     Here is a proof.
% \end{proof}


% \begin{lemma}\label{almost_equal_fill_hole}
%     \leanok
%     \lean{almost_equal_fill_hole}
%     \uses{with_hole}
%     Here is a definition.
% \end{lemma}
% \begin{proof}
%     Here is a proof.
% \end{proof}

% \begin{lemma}\label{filled_hole_replace}
%     \leanok
%     \lean{filled_hole_replace}
%     \uses{with_hole}
%     Here is a definition.
% \end{lemma}
% \begin{proof}
%     Here is a proof.
% \end{proof}

% \begin{lemma}\label{unfill_fill_hole}
%     \leanok
%     \lean{unfill_fill_hole}
%     \uses{with_hole}
%     Here is a definition.
% \end{lemma}
% \begin{proof}
%     Here is a proof.
% \end{proof}

% \begin{definition}\label{monotone}
%     \leanok
%     \lean{monotone}
%     Here is a definition.
% \end{definition}

% \begin{definition}\label{implementable}
%     \leanok
%     \lean{implementable}
%     Here is a definition.
% \end{definition}

% \begin{theorem}\label{payment_sandwich}
%     \leanok
%     \lean{payment_sandwich}
%     \uses{with_hole, filled_hole_almost_equal, utility}
%     Here is a definition.
% \end{lemma}
% \begin{proof}
%     Here is a proof.
% \end{proof}

% \begin{theorem}\label{implementable_impl_monotone}
%     \leanok
%     \lean{implementable_impl_monotone}
%     \uses{implementable, monotone, payment_sandwich, 
%     nonpos_of_mul_nonpos_righ, with_hole}
%     Here is a definition.
% \end{lemma}
% \begin{proof}
%     Here is a proof.
% \end{proof}


% \begin{definition}\label{magic_payment_rule}
%     \leanok
%     \lean{magic_payment_rule}
%     \uses{with_hole}
%     Here is a definition.
% \end{definition}


% \begin{definition}\label{with_magic}
%     \leanok
%     \lean{with_hole}
%     \uses{magic_payment_rule}
%     Here is a definition.
% \end{definition}

% \begin{definition}\label{utility_exp}
%     \leanok
%     \lean{utility_exp}
%     \uses{utility, with_magic, with_hole}
%     Here is a definition.
% \end{definition}









